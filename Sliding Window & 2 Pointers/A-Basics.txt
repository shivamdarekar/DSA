* When to use Two Pointers?
Use when:
- Array / string involved
- Order matters (sorted or positional)
- Need to compare elements efficiently
- Brute force feels O(n¬≤)

Don‚Äôt use when:
- Data unordered & no rule to move pointers
- Need random access comparisons


*- Sliding window me hum ek continuous subarray / substring (window) maintain 
   karte hain aur us window ko expand ya shrink karte rehte hain.

- in sliding window We maintain a running sum for a fixed-size window and update it 
by adding the incoming element and removing the outgoing element as the window slides, achieving O(n) time complexity.
   
üîπ Sliding Window kab use karein?
Conditions must satisfy:
1Ô∏è‚É£ Contiguous subarray / substring
2Ô∏è‚É£ Window ka koi property ho
     - sum
     - count
     - frequency
3Ô∏è‚É£ Window grow/shrink logically possible ho


keyword	                       Use

Reverse	                   Two pointers
Palindrome	                Two pointers
Sorted array	             Two pointers
Subarray / substring	       Sliding window
Maximum / minimum window	 Sliding window
Longest / shortest	       Sliding window
At most / at least	       Sliding window
Continuous	                Sliding window


Use HashSet when:
 - Sirf presence / absence check karni ho
 - Frequency ka koi role nahi
 - Duplicate allowed nahi window me

Typical conditions:
 - ‚ÄúNo repeating characters‚Äù
 - ‚ÄúAll elements distinct‚Äù

  Situation	                  Use
Only unique check	           HashSet
Count / frequency	           HashMap
Distinct limit	              HashMap
No duplicates allowed	     HashSet
Remove only when count = 0	  HashMap


- exactly K = atMost(K) ‚àí atMost(K‚àí1)
 use this approach when The problem asks for ‚Äúexactly K‚Äù
- Look for words like:
  - exactly K
  - equal to K
  - precisely K
  - sum = K
  - K distinct
- also we able so cal at most easily

-examples
1Ô∏è‚É£ Subarrays with exactly K distinct integers
2Ô∏è‚É£ Binary subarrays with sum = K
3Ô∏è‚É£ Subarrays with exactly K odd numbers
4Ô∏è‚É£ Subarrays with exactly K zeros
5Ô∏è‚É£ Longest / count subarrays with exactly K constraints


Longest / Shortest       ‚Üí Variable window
At most K                ‚Üí Sliding window + count
Exactly K                ‚Üí atMost(K) - atMost(K-1)
Fixed size K             ‚Üí Sliding window (add right, remove left)
